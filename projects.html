<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wahaj Aslam | Projects</title>
    <link rel="stylesheet" href="style.css">
</head>
<body class="projects-page">

    <header class="top-header">
        <div class="ribbon-nav">
            <a href="index.html" class="ribbon-link">RESUME</a>
            <span style="color:var(--card-border)">|</span>
            <a href="projects.html" class="ribbon-link active">PROJECTS</a>
            <span style="color:var(--card-border)">|</span>
            <a href="mygpt.html" class="ribbon-link">GPT</a>
        </div>
        <button class="theme-switch" id="themeToggle" onclick="toggleTheme()">THEME</button>
    </header>

    <main>
        <section id="archive">
            <!--
            <div class="section-header">
                <span class="label">// PROJECT ARCHIVE</span>
            </div>
            <hr class="section-divider active">
            -->
            <div class="archive-filters" id="archiveFilters" aria-label="Filter projects by tag"></div>

            <div class="archive-wrapper">
                <!-- Buttons placed on sides -->
                <button class="nav-btn prev" id="prevBtn" aria-label="Scroll Left">←</button>
                <button class="nav-btn next" id="nextBtn" aria-label="Scroll Right">→</button>

                <div class="vhs-gallery" id="galleryContainer">
                    <!-- Javascript will inject cards here -->
                </div>
            </div>

            <!-- Details Section pushed down -->
            <div class="details-section blur-fade active">
                <div class="details-meta">
                    <span class="label">CURRENT SELECTION</span>
                    <h2 id="detailTitle">Select a Title</h2>
                    <p id="detailYear">--</p>
                    <div id="detailTags" class="detail-tags"></div>
                    <div id="detailToc" class="detail-toc"></div>
                </div>
                <div class="details-body">
                    <p id="detailDesc">Browse the archive above. Click a tape to load details from the vault.</p>
                    <div id="detailContent" class="detail-article"></div>
                    <div id="detailActions" class="detail-actions"></div>
                </div>
            </div>
        </section>
    </main>

    <script>
        const projectSlugs = [
            'my-live-portfolio',
            'post-processing-separated-speech',
            'vidi',
            'beatnik-osc-glove',
            'laser-harp',
            'parallel-av-encoding-framework',
            'dtmf_detector',
            'traffic_signal_controller',
            'arp_spoof_detector',
            'parking_management_system',
            'multihop_wireless_warp_prototyping',
            'massive_mimo_seminar'
        ];

        const MAX_TAGS = 10;
        let allowedTagsSet = null;
        let galleryShown = false;

        async function ensureAllowedTags() {
            if (allowedTagsSet) return allowedTagsSet;
            try {
                const res = await fetch('data/tags.json', { cache: 'no-cache' });
                if (!res.ok) throw new Error('tags.json fetch failed');
                const arr = await res.json();
                allowedTagsSet = new Set(
                    Array.isArray(arr)
                        ? arr.map(t => String(t).trim()).filter(Boolean)
                        : []
                );
            } catch (err) {
                console.warn('Unable to load central tag list; skipping validation.', err);
                allowedTagsSet = new Set();
            }
            return allowedTagsSet;
        }

        async function fetchProject(slug) {
            const paths = [
                `projects/${slug}/index.md`,
                `projects/${slug}.md` // legacy fallback
            ];
            let markdown = '';
            let usedPath = '';

            for (const path of paths) {
                const res = await fetch(path, { cache: 'no-store' });
                if (res.ok) {
                    markdown = await res.text();
                    usedPath = path;
                    break;
                }
            }

            if (!markdown) throw new Error(`Failed to load any markdown for ${slug}`);

            const { meta, body } = parseFrontMatter(markdown);

            const title = meta.title || deriveTitleFromSlug(slug);
            let tags = Array.isArray(meta.tags)
                ? Array.from(new Set(
                    meta.tags
                        .map(t => String(t).trim())
                        .filter(Boolean)
                  ))
                : [];

            const hasAllowlist = allowedTagsSet && allowedTagsSet.size > 0;
            if (hasAllowlist) {
                const original = tags;
                tags = tags.filter(t => allowedTagsSet.has(t));
                const missing = original.filter(t => !allowedTagsSet.has(t));
                if (missing.length) {
                    console.warn(`Project "${slug}" uses tags not in data/tags.json:`, missing);
                }
            }

            tags = tags.slice(0, MAX_TAGS);

            return {
                title,
                year: meta.year || '',
                format: meta.format || '',
                code: meta.code || '',
                desc: meta.summary || '',
                tags,
                image: meta.cover_image || '',
                contentPath: usedPath,
                articleSlug: meta.article_slug || slug,
                body
            };
        }

        const container = document.getElementById('galleryContainer');
        const filterContainer = document.getElementById('archiveFilters');
        const detailTitle = document.getElementById('detailTitle');
        const detailDesc = document.getElementById('detailDesc');
        const detailContent = document.getElementById('detailContent');
        const detailYear = document.getElementById('detailYear');
        const detailTags = document.getElementById('detailTags');
        const detailActions = document.getElementById('detailActions');
        const detailToc = document.getElementById('detailToc');
        if (container) container.classList.add('loading');

        const finishGalleryLoading = () => {
            if (!container || galleryShown) return;
            galleryShown = true;
            requestAnimationFrame(() => requestAnimationFrame(() => container.classList.remove('loading')));
        };

        let activeIndex = -1;
        let activeTags = [];
        let lastScrollPosition = 0;
        let centerActiveOnRender = false;
        let archiveData = [];
        let allTags = [];
        const contentCache = new Map();
        let detailRequestId = 0;

        function deriveTitleFromSlug(value) {
            if (!value) return 'Project';
            return value
                .replace(/_/g, '-')
                .split('-')
                .filter(Boolean)
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        function parseFrontMatter(md) {
            const frontMatterMatch = md.match(/^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/);
            if (!frontMatterMatch) {
                return { meta: {}, body: md };
            }

            const metaLines = frontMatterMatch[1].split('\n');
            const meta = {};
            metaLines.forEach(line => {
                const idx = line.indexOf(':');
                if (idx === -1) return;
                const key = line.slice(0, idx).trim();
                let value = line.slice(idx + 1).trim();

                if (value.startsWith('"') && value.endsWith('"')) {
                    value = value.slice(1, -1);
                } else if (value.startsWith("'") && value.endsWith("'")) {
                    value = value.slice(1, -1);
                } else if (value.startsWith('[') && value.endsWith(']')) {
                    const inner = value.slice(1, -1).trim();
                    value = inner
                        ? inner.split(',').map(v => v.trim().replace(/^['"]|['"]$/g, ''))
                        : [];
                }
                meta[key.replace(/-/g, '_')] = value;
            });

            return { meta, body: frontMatterMatch[2] };
        }

        function escapeHtml(str) {
            return str
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function renderMarkdown(md) {
            const lines = md.replace(/\r\n/g, '\n').split('\n');
            let html = '';
            let inList = false;
            const slugCounts = {};

            const formatInline = (text) => {
                const escaped = escapeHtml(text);
                return escaped
                    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.+?)\*/g, '<em>$1</em>');
            };

            const slugify = text => {
                const base = text
                    .toLowerCase()
                    .replace(/[^a-z0-9]+/g, '-')
                    .replace(/^-+|-+$/g, '') || 'section';
                const count = (slugCounts[base] || 0) + 1;
                slugCounts[base] = count;
                return count === 1 ? base : `${base}-${count}`;
            };

            const closeList = () => {
                if (inList) {
                    html += '</ul>';
                    inList = false;
                }
            };

            lines.forEach(rawLine => {
                const line = rawLine.trimEnd();
                if (!line.trim()) {
                    closeList();
                    return;
                }

                if (line === '---' || line === '⸻') {
                    closeList();
                    html += '<div class="detail-divider">⸻</div>';
                    return;
                }

                const headingMatch = line.match(/^(#{1,3})\s+(.*)$/);
                if (headingMatch) {
                    closeList();
                    const level = headingMatch[1].length;
                    const text = headingMatch[2].trim();
                    const tag = ['h3', 'h4', 'h5'][level - 1] || 'h5';
                    const id = slugify(text);
                    html += `<${tag} id="${id}">${formatInline(text)}</${tag}>`;
                    return;
                }

                if (/^[-*]\s+/.test(line)) {
                    if (!inList) html += '<ul>';
                    inList = true;
                    html += `<li>${formatInline(line.replace(/^[-*]\s+/, ''))}</li>`;
                    return;
                }

                closeList();
                html += `<p>${formatInline(line)}</p>`;
            });

            if (inList) html += '</ul>';
            return html;
        }

        function adjustEdgePadding() {
            if (!container) return;
            const activeWidth = 450; // match .vhs-item.active width
            const gap = Math.min(160, Math.max(32, (container.clientWidth - activeWidth) / 2));
            container.style.setProperty('--vhs-edge-gap', `${gap}px`);
        }

        async function loadProjects() {
            try {
                await ensureAllowedTags();
                const results = await Promise.allSettled(projectSlugs.map(fetchProject));
                const successes = results
                    .filter(r => r.status === 'fulfilled')
                    .map(r => r.value);
                const failures = results.filter(r => r.status === 'rejected');

                if (!successes.length) throw new Error('No projects loaded');

                archiveData = successes;
                allTags = Array.from(new Set(archiveData.flatMap(item => item.tags || [])));
                renderFilters();
                renderGallery();
                adjustEdgePadding();
                requestAnimationFrame(centerGalleryToMiddle);

                if (failures.length) {
                    console.warn('Some projects failed to load:', failures.map(f => f.reason));
                }
            } catch (err) {
                detailTitle.innerText = 'Unable to load projects';
                detailDesc.innerText = 'Please try again later.';
            }
        }

        async function loadArticle(item) {
            if (!item.contentPath && !item.body) return '';
            const cacheKey = item.articleSlug || item.title;
            if (contentCache.has(cacheKey)) return contentCache.get(cacheKey);

            let text = item.body || '';

            if (!text && item.contentPath) {
                const response = await fetch(item.contentPath, { cache: 'no-cache' });
                if (!response.ok) throw new Error('Failed to load content');
                text = await response.text();
            }

            // Strip front matter if it slipped through
            const parsed = parseFrontMatter(text);
            text = parsed.body || text;
            text = text.replace(/^---\s*\n[\s\S]*?\n---\s*\n/, '');

            const html = renderMarkdown(text);
            contentCache.set(cacheKey, html);
            return html;
        }

        const getFilteredData = () => activeTags.length === 0
            ? archiveData
            : archiveData.filter(item => activeTags.some(tag => item.tags.includes(tag)));

        function renderFilters() {
            if (!filterContainer) return;
            filterContainer.innerHTML = '';
            const tags = ['ALL', ...allTags];
            tags.forEach(tag => {
                const isAll = tag === 'ALL';
                const isActive = isAll ? activeTags.length === 0 : activeTags.includes(tag);
                const btn = document.createElement('button');
                btn.className = `filter-chip ${isActive ? 'active' : ''}`;
                btn.innerText = isAll ? 'ALL' : `${tag}`;
                btn.setAttribute('aria-pressed', isActive);
                btn.onclick = () => {
                    if (isAll) {
                        activeTags = [];
                    } else {
                        activeTags = activeTags.includes(tag)
                            ? activeTags.filter(t => t !== tag)
                            : [...activeTags, tag];
                    }
                    activeIndex = -1;
                    resetDetails();
                    renderFilters();
                    renderGallery();
                };
                filterContainer.appendChild(btn);
            });
        }

        function centerCard(el) {
            const desired = el.offsetLeft - (container.clientWidth - el.offsetWidth) / 2;
            const maxScroll = Math.max(0, container.scrollWidth - container.clientWidth);
            const target = Math.min(Math.max(0, desired), maxScroll);
            container.scrollTo({ left: target, behavior: 'smooth' });
        }

        function setActiveIndex(newIndex) {
            const filtered = getFilteredData();
            if (!filtered.length) return;
            const count = filtered.length;
            const normalized = ((newIndex % count) + count) % count; // wrap
            lastScrollPosition = container.scrollLeft;
            activeIndex = normalized;
            updateDetails(filtered[normalized]);
            centerActiveOnRender = true;
            renderGallery();
        }

        function centerGalleryToMiddle() {
            if (!container) return;
            const isScrollable = container.scrollWidth > container.clientWidth + 1;
            container.classList.toggle('centered', !isScrollable);

            if (isScrollable) {
                const target = Math.max(0, (container.scrollWidth - container.clientWidth) / 2);
                container.scrollTo({ left: target });
            } else {
                container.scrollLeft = 0;
            }
        }

        function renderGallery() {
            container.innerHTML = '';
            const filtered = getFilteredData();

            // guard active index in filtered view
            if (activeIndex >= filtered.length) {
                activeIndex = -1;
                resetDetails();
            }

            filtered.forEach((item, index) => {
                const el = document.createElement('div');
                const isActive = (index === activeIndex);
                el.className = `vhs-item ${isActive ? 'active' : ''}`;
                
                // Content Structure
                el.innerHTML = `
                    <!-- Closed Spine State -->
                    <div class="vhs-spine-content">
                        <div class="vhs-code">${item.code}</div>
                        <div class="vhs-spine-text">${item.title}</div>
                        <div class="vhs-code">${item.year}</div>
                        <div class="vhs-play-icon" aria-hidden="true">▶</div>
                    </div>

                    <!-- Open Card State -->
                    <div class="vhs-open-content">
                        <img src="${item.image}" class="vhs-img-bg" alt="Cover">
                        <div class="vhs-info-layer">
                            <h3 class="vhs-title">${item.title}</h3>
                            <p class="vhs-desc">${item.desc}</p>
                            <div class="vhs-tags">
                                ${item.tags.map(t => `<span class="vhs-tag">${t}</span>`).join('')}
                            </div>
                        </div>
                    </div>
                `;

                // Click Handler
                el.onclick = () => {
                    if (activeIndex === index) {
                        activeIndex = -1; // Close if clicking same
                        resetDetails();
                        centerActiveOnRender = false;
                        renderGallery();
                        container.scrollTo({ left: lastScrollPosition, behavior: 'smooth' });
                    } else {
                        lastScrollPosition = container.scrollLeft;
                        activeIndex = index;
                        updateDetails(item);
                        centerActiveOnRender = true;
                        renderGallery();
                    }
                };

                container.appendChild(el);
            });

            if (centerActiveOnRender && activeIndex >= 0) {
                requestAnimationFrame(() => {
                    const activeEl = container.querySelector('.vhs-item.active');
                    if (activeEl) centerCard(activeEl);
                    centerActiveOnRender = false;
                    finishGalleryLoading();
                });
            }

            // When nothing is active, keep the carousel centered
            if (activeIndex === -1) {
                requestAnimationFrame(centerGalleryToMiddle);
                finishGalleryLoading();
            }
        }

        function buildToc() {
            if (!detailToc) return;
            detailToc.innerHTML = '';
            const headings = detailContent.querySelectorAll('h3, h4, h5');
            if (!headings.length) return;
            const list = document.createElement('ul');
            list.className = 'toc-list';
            headings.forEach(h => {
                const id = h.id || h.textContent.trim().toLowerCase().replace(/[^a-z0-9]+/g, '-');
                if (!h.id) h.id = id || 'section';
                const li = document.createElement('li');
                li.className = `toc-item level-${h.tagName.toLowerCase()}`;
                const link = document.createElement('a');
                link.href = `#${h.id}`;
                link.textContent = h.textContent.trim();
                li.appendChild(link);
                list.appendChild(li);
            });
            detailToc.innerHTML = '<span class=\"toc-label\">Contents</span>';
            detailToc.appendChild(list);
        }

        function updateDetails(item) {
            detailTitle.innerText = item.title;
            detailDesc.innerText = item.desc;
            const metaLine = [item.year, item.format].filter(Boolean).join(' // ');
            detailYear.innerText = metaLine || '--';
            detailToc.innerHTML = '';
            // Scroll container to keep active card centered when opened
            requestAnimationFrame(() => {
                const activeEl = container.querySelector('.vhs-item.active');
                if (activeEl) centerCard(activeEl);
            });
            detailTags.innerHTML = item.tags.map(t => `<span class="detail-tag">${t}</span>`).join('');
            detailActions.innerHTML = item.articleSlug
                ? `<a class="detail-link" href="article.html?article=${encodeURIComponent(item.articleSlug)}">Open full article</a>`
                : '';
            detailContent.innerHTML = item.contentPath
                ? '<p class="detail-loading">Loading tape...</p>'
                : '';

            const requestId = ++detailRequestId;

            if (item.contentPath) {
                loadArticle(item)
                    .then(html => {
                        if (requestId !== detailRequestId) return;
                        detailContent.innerHTML = html;
                        buildToc();
                    })
                    .catch(() => {
                        if (requestId !== detailRequestId) return;
                        detailContent.innerHTML = '<p>Unable to load this tape right now.</p>';
                    });
            }
            
            // Subtle fade animation for text change
            const section = document.querySelector('.details-section');
            section.style.opacity = 0.5;
            setTimeout(() => section.style.opacity = 1, 200);
        }

        function resetDetails() {
            detailRequestId++; // invalidate any in-flight content loads
            detailTitle.innerText = "Select a Project Tape";
            detailDesc.innerText = "Browse the archive above. Click a project tape to load details.";
            detailYear.innerText = "--";
            detailContent.innerHTML = "";
            detailTags.innerHTML = "";
            detailActions.innerHTML = "";
            detailToc.innerHTML = "";
        }

        // Horizontal Scroll Buttons
        document.getElementById('prevBtn').onclick = () => {
            const filtered = getFilteredData();
            if (!filtered.length) return;
            if (activeIndex === -1) {
                setActiveIndex(filtered.length - 1);
            } else {
                setActiveIndex(activeIndex - 1);
            }
        };
        document.getElementById('nextBtn').onclick = () => {
            const filtered = getFilteredData();
            if (!filtered.length) return;
            if (activeIndex === -1) {
                setActiveIndex(0);
            } else {
                setActiveIndex(activeIndex + 1);
            }
        };

        // Theme Toggle Logic
        const html = document.documentElement;
        const themes = ['light', 'dark'];
        let currentThemeIdx = 0;
        
        // Check local storage or default
        (function initTheme() {
            let saved = localStorage.getItem('theme') || 'light';
            if (!themes.includes(saved)) saved = 'light';
            html.setAttribute('data-theme', saved);
            // set button text to NEXT theme
            const next = themes[(themes.indexOf(saved) + 1) % themes.length];
            document.getElementById('themeToggle').innerText = next.toUpperCase();
        })();

        function toggleTheme() {
            const current = html.getAttribute('data-theme');
            const idx = themes.indexOf(current);
            const next = themes[(idx + 1) % themes.length];
            html.setAttribute('data-theme', next);
            const afterNext = themes[(idx + 2) % themes.length];
            document.getElementById('themeToggle').innerText = afterNext.toUpperCase();
            localStorage.setItem('theme', next);
        }

        // Init
        loadProjects().then(centerGalleryToMiddle);
        window.addEventListener('resize', () => {
            adjustEdgePadding();
            requestAnimationFrame(centerGalleryToMiddle);
        });
        adjustEdgePadding();

    </script>
</body>
</html>
