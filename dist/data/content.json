[
  {
    "id": "experience/fraunhofer/index.md",
    "collection": "experience",
    "slug": "fraunhofer",
    "url": null,
    "word_count": 827,
    "data": {
      "visibility": "public",
      "use_for_ai": true,
      "tags": [
        "audio",
        "dsp",
        "codec",
        "streaming",
        "c",
        "c++",
        "python",
        "ci_cd",
        "critical_listening"
      ]
    },
    "content": "\n# Fraunhofer IIS ‚Äì Audio & DSP Engineer\n\n## Role Summary\n\nAt Fraunhofer IIS, I worked as an Audio/DSP Engineer on tools and components around modern audio\ncodecs such as MPEG-H 3D Audio and xHE-AAC. The work combined:\n\n- **C-based DSP and systems engineering**\n- **Modern C++ integration and tooling**\n- **Python-based evaluation and automation**\n- **Critical listening and artifact analysis**\n- **Streaming-oriented validation** of encoder behavior in ecosystems used by major platforms like  \n  **Netflix, Amazon Music, YouTube, and Microsoft** (public ecosystem level, not confidential).\n\nThis role forced me to think end-to-end: from a line of C code in a DSP block to how that change\naffects perceived quality in a streaming scenario.\n\n---\n\n## Key Responsibilities (Non-Confidential)\n\n### 1. DSP & System-Level Development in C\n\n- Implemented and maintained performance-critical C modules used in internal encoder / toolchain flows.\n- Worked on signal-path logic, buffer management, state handling, and configuration-dependent behavior.\n- Ensured stability and determinism across multiple operating modes and platforms.\n\n### 2. Modern C++ Tools & Media Integration (MFT)\n\n- Developed C++ utilities and test applications around encoders/decoders.\n- Integrated components into **Microsoft Windows Media Foundation (MFT)** to simulate realistic playback /\n  processing pipelines.\n- Built small frameworks / harnesses for automated end-to-end tests in media-like environments.\n\n### 3. Streaming-Oriented Encoder Validation\n\n- Supported test flows that mirror **streaming use cases**:\n  - ABR-style bitrate ladders\n  - Segment-based encoding behavior\n  - Consistency across renditions and presets\n  - Handling of metadata / loudness / configuration changes\n- Participated in internal evaluations that reflect usage by major streaming platforms  \n  (e.g. Netflix, Amazon Music, YouTube, Microsoft ‚Äì as publicly associated with these codecs).\n\n### 4. Python Automation & Evaluation Frameworks\n\n- Wrote Python scripts to:\n  - run batch encoder evaluations,\n  - compare different builds / presets,\n  - generate plots and numerical summaries,\n  - manage input/output sets for regression testing.\n- Automated repetitive tasks (e.g. multiple bitrate runs, content sets, preset combinations) to make\n  evaluation more systematic and less manual.\n\n### 5. CI/CD & Engineering Operations\n\n- Contributed to **GitLab CI** pipelines to ensure regular automated builds and tests.\n- Used Bash/Python glue to orchestrate multi-stage test jobs and artifact handling.\n- Helped improve reliability of the evaluation pipeline over time.\n\n---\n\n## Critical Listening & Perceptual Analysis\n\n### 6. Critical Listening & Artifact Detection\n\n- Spent **hundreds of hours** in structured listening sessions across speech, music and complex content.\n- Developed the ability to detect and classify artifacts such as:\n  - pre-echo\n  - transient smearing\n  - metallic ringing / ‚Äúmetallic‚Äù voices\n  - spectral holes / narrowband notches\n  - high-band / low-band tone mismatch\n  - roughness / hiss / ‚Äúsynthetic‚Äù timbre\n  - stereo image instability or collapse\n- Learned to connect what I heard to what I saw in:\n  - spectrograms (Adobe Audition, Python/MATLAB plots),\n  - waveforms,\n  - difference signals and diagnostic views.\n\n### 7. Audio Analysis Tools & Workflow\n\nRegularly used:\n\n- **Adobe Audition** ‚Äì spectrograms, transient analysis, zooming into problem regions.\n- **FFmpeg** ‚Äì transcoding, re-encoding, ABR ladder generation, waveform extraction, segmenting.\n- **MediaInfo** ‚Äì checking codec configuration, bitrate, channel layouts, and container info.\n- **Python/MATLAB** ‚Äì custom plots (LPC envelopes, spectral envelopes, error curves, etc.).\n- Internal waveform / spectrum tools to localize issues and verify fixes.\n\nThis toolchain became my standard way to **triangulate** issues: listen ‚Üí visualize ‚Üí inspect metadata ‚Üí\nadjust DSP logic or configuration.\n\n---\n\n## Achievements\n\n- **Perceptual Quality Safeguard**  \n  Identified subtle artifacts in internal evaluation runs (for specific content types and bitrates) that were\n  not obvious from metrics alone, helping prevent regressions from progressing further.\n\n- **Streaming-Aligned Testing**  \n  Contributed to testing setups that better reflected how encoders behave in streaming-style usage  \n  (bitrates, segments, switching scenarios), improving confidence for ecosystem deployments involving\n  platforms like Netflix, Amazon Music, YouTube, and Microsoft.\n\n- **Evaluation Pipeline Reliability**  \n  Helped stabilize Python-driven evaluation flows and CI jobs so that larger sets of tests could run more\n  reliably without manual babysitting.\n\n- **Cross-Domain Intuition**  \n  Built strong intuition linking:\n  - mathematical changes in DSP modules,\n  - visual patterns in spectrograms / plots,\n  - and final perceptual outcomes.\n\n---\n\n## Narration / Stories\n\n### Story ‚Äì When a Small Change Became a Big Artifact\n\nA small change in one block produced a faint but irritating metallic ringing only on specific female\nvocals with strong high-frequency content. On paper the change looked harmless; metrics hardly moved.\nBut listening exposed a clear regression. Looking at spectrograms showed a narrowband spike that lined\nup exactly with what I heard. That moment reinforced a key lesson: **perception is the final judge**, not\njust numbers.\n\n### Story ‚Äì Thinking Like a Streaming Engineer, Not Just a DSP Engineer\n\nWorking on streaming-oriented tests forced me to care about:\n- how the encoder behaves across an ABR ladder,\n- what happens when bitrates switch,\n- how metadata and loudness are preserved,\nnot just how ‚Äúclean‚Äù a single coded file sounds under ideal conditions. That shifted my mindset from\npure DSP to **system-level media engineering**.\n\n---"
  },
  {
    "id": "experience/tu_darmstadt/index.md",
    "collection": "experience",
    "slug": "tu_darmstadt",
    "url": null,
    "word_count": 200,
    "data": {
      "visibility": "public",
      "use_for_ai": true,
      "tags": [
        "wireless",
        "matlab",
        "sdr",
        "research"
      ]
    },
    "content": "\n# TU Darmstadt ‚Äì Research Assistant (HiWi)\n\n## Role Summary\n\nAs a research assistant in wireless communications, I supported experiments using **WARP SDR** and\ndeveloped **MATLAB visualization tools** to understand multi-hop and cooperative wireless behavior.\nThe role sat between research and engineering: turning equations and concepts into real measurements\nand plots.\n\n---\n\n## Responsibilities\n\n- Developed MATLAB GUIs to visualize multi-hop paths, relay behavior and packet flows.\n- Helped set up and run WARP-based experiments (cooperative forwarding, multi-hop chains).\n- Wrote analysis scripts (MATLAB / Python) to interpret logs and timing data.\n- Assisted with preparing figures and structured results for academic use.\n\n---\n\n## Achievements\n\n- Delivered visualization tools that other students / researchers could use to understand multi-hop\n  experiments more intuitively.\n- Helped make experiments more **repeatable**: clearer logging, structured scripts, and consistent setups.\n\n---\n\n## Narration\n\nThis work made wireless systems more ‚Äúreal‚Äù for me. Instead of only thinking in terms of channel matrices\nand equations, I could see how packets and relays actually behaved in practice. It also taught me that\neven research tools benefit from basic engineering discipline‚Äîif others are going to use a script or GUI,\nit needs to be structured and understandable."
  },
  {
    "id": "experience/u_blox/index.md",
    "collection": "experience",
    "slug": "u_blox",
    "url": null,
    "word_count": 316,
    "data": {
      "visibility": "public",
      "use_for_ai": true,
      "tags": [
        "lte",
        "nas",
        "c",
        "embedded",
        "protocols"
      ]
    },
    "content": "\n# u-blox ‚Äì LTE NAS Engineer\n\n## Role Summary\n\nAt u-blox, I worked as an Embedded Protocol Engineer on **LTE NAS (Non-Access Stratum)** for cellular\nmodules. The work was centered around **C-based state machines**, **3GPP-compliant signaling**, and\n**trace-driven debugging** for attach / detach / mobility / security procedures.\n\n---\n\n## Key Responsibilities\n\n### 1. NAS State Machine Development in C\n\n- Implemented and maintained LTE NAS procedures:\n  - attach / detach,\n  - tracking area update (TAU),\n  - basic mobility-related signaling.\n- Followed relevant 3GPP specs for message formats, timers and expected state transitions.\n- Handled error paths and corner cases that arise in real networks.\n\n### 2. Mobility & Security Flows\n\n- Contributed to security-related NAS flows (e.g. security mode procedures) at a high level.\n- Ensured correct interaction with mobility procedures so the device behaves predictably as it moves\n  across cells / regions.\n\n### 3. AT Command Integration\n\n- Mapped NAS procedures to AT commands used by external control (e.g. attach control, network info).\n- Ensured AT behavior was consistent and predictable for integrators.\n\n### 4. Trace-Based Debugging & Automation\n\n- Analyzed NAS traces and logging output to find where and why flows broke.\n- Used Python and simple scripts to replay or post-process traces and verify changes.\n\n---\n\n## Achievements\n\n- **Improved NAS Stability**  \n  Helped fix issues in NAS flows (e.g. attach / TAU behavior) based on trace findings, reducing failure cases.\n\n- **Better Debugging Workflows**  \n  Contributed scripts / approaches to make investigating signaling problems faster and more systematic.\n\n---\n\n## Narration\n\nThis role trained me to think in **state machines and protocol flows**. You can‚Äôt just ‚Äúhack something in‚Äù\nwhen dealing with NAS‚Äîone missing transition or mishandled timer can break connectivity. The habit of\nreading traces carefully and mapping them back to code paths carried over to my later work in DSP and\nmedia, where failures are also often indirect and subtle."
  },
  {
    "id": "profile/profile.md",
    "collection": "profile",
    "slug": "profile",
    "url": null,
    "word_count": 653,
    "data": {
      "visibility": "public",
      "use_for_ai": true,
      "tags": [
        "profile",
        "career_summary",
        "audio_dsp",
        "embedded",
        "software_engineering"
      ]
    },
    "content": "\n# Professional Profile ‚Äî Wahaj Aslam  \n### Audio/DSP Engineer ‚Ä¢ Embedded Systems ‚Ä¢ Real-Time Media ‚Ä¢ Research‚ÄëDriven Problem Solver\n\n---\n\n## 1. Who I Am\n\nI am an engineer who works at the intersection of **audio signal processing**, **embedded systems**, and\n**high‚Äëperformance software development**.  \nMy background spans **research**, **product engineering**, and **system‚Äëlevel debugging**, with hands-on \nexperience building tools, algorithms, and testing frameworks that must perform reliably under real‚Äëtime \nconstraints.\n\nI approach problems by balancing:\n\n- scientific rigor,  \n- practical engineering constraints, and  \n- user‚Äëcentered intuition (how the system *should feel*).  \n\nMy work ranges from **DSP research** (speech bandwidth extension, pitch systems, wireless modeling) to\n**industry-grade product work**, such as audio codec feature development, media streaming, system-level\nintegration, and critical listening analysis.\n\n---\n\n## 2. What I‚Äôm Good At\n\n### **DSP & Audio Engineering**\n- Pitch detection, enhancement, envelopes, filters, formants, spectral analysis  \n- Real-time DSP pipelines (Core Audio, vDSP, FFT optimization)  \n- Speech bandwidth extension, time‚Äëfrequency modeling  \n- Algorithm tuning through critical listening and perceptual analysis  \n\n### **Embedded & Systems Engineering**\n- C as a primary language (Fraunhofer systems work)  \n- Modern C++ for application frameworks, tools, and integration layers  \n- Python for research tooling, automation, concurrency, data analysis  \n- Real-time debugging, timing constraints, memory-sensitive systems  \n\n### **Media, Streaming & Codec Work**\n- Working with internal encoders/decoders  \n- Streaming‚Äërelevant features  \n- Quality investigations based on artifacts, logs, bitstreams  \n- Tools such as FFmpeg, MediaInfo, Adobe Audition, internal QA systems  \n\n### **Signal Testing & Evaluation**\n- Critical listening sessions (hundreds of hours)  \n- Subjective + objective evaluation of audio quality  \n- Artifact identification, regression detection  \n- Designing test plans and experiments  \n\n---\n\n## 3. How I Work\n\n### **Scientifically**\nI rely on theory where it matters:\n- modeling signals,  \n- evaluating tradeoffs,  \n- tuning algorithms based on measurable behavior.\n\n### **Practically**\nI make engineering decisions based on:\n- latency budgets,  \n- CPU/memory constraints,  \n- integration realities,  \nnot just idealized models.\n\n### **Empirically**\nI frequently prototype in Python or MATLAB, validate ideas, compare outputs, and refine them using:\n- spectral visualization,  \n- waveform inspection,  \n- controlled listening tests.\n\n### **Collaboratively**\nI work well with:\n- researchers,  \n- QA teams,  \n- firmware engineers,  \n- product teams,  \nensuring alignment between DSP theory and product needs.\n\n---\n\n## 4. Where I‚Äôve Worked\n\n### **Fraunhofer IIS ‚Äî Audio, Video & Media Systems**\n- C as primary development language  \n- Audio codec feature development  \n- Streaming-related system integration  \n- Artifact detection and quality analysis  \n- Critical listening evaluations  \n- Encoder/decoder feature testing and debugging  \n- Worked indirectly with formats and customers such as Netflix, Amazon, Microsoft, etc.  \n\n### **u‚Äëblox**\n- Systems-level engineering  \n- DSP‚Äëadjacent tasks  \n- C/C++ tooling development  \n- Software testing and integration work  \n\n### **TU Darmstadt (Research)**\n- Speech bandwidth extension (master thesis)  \n- Wireless modeling and MATLAB tool development  \n- Academic research presentations and implementation work  \n\n---\n\n## 5. What I Bring to a Team\n\n- **End‚Äëto‚Äëend ownership**: from research ‚Üí prototyping ‚Üí implementation ‚Üí evaluation.  \n- **Strong debugging intuition**, especially in timing-/signal-/quality‚Äësensitive systems.  \n- **Cross‚Äëdisciplinary thinking**, blending DSP, embedded design, and software engineering.  \n- **Fast context ramp‚Äëup** due to years of switching between research and product environments.  \n- **Stability under complexity** ‚Äî I thrive in problem spaces where correctness, latency, and subjective \nquality all intersect.  \n\n---\n\n## 6. Personal Narrative (Short)\n\nI enjoy building systems that *sound good*, not just ones that *compute correctly*.  \nMuch of my work centers around bridging the gap between raw algorithms and real‚Äëworld perception‚Äîwhether \nI‚Äôm tuning a bandwidth extension model, optimizing a pitch detector, or helping evaluate codec behavior.\n\nI‚Äôm driven by curiosity, long-term skill growth, and the satisfaction of making complex systems behave in\nclean, predictable, and perceptually meaningful ways.\n\n---\n\n## 7. Personal Interests\n\n- DSP research & algorithm design  \n- Audio enhancement and reconstruction  \n- Musical interface design (gestural controllers, pitch tools)  \n- Wireless systems  \n- System-level tooling, automation, and testing  \n- Continuous self‚Äëimprovement and learning  \n"
  },
  {
    "id": "projects/arp_spoof_detector/index.md",
    "collection": "projects",
    "slug": "arp_spoof_detector",
    "url": "/projects/arp_spoof_detector/",
    "word_count": 542,
    "data": {
      "visibility": "public",
      "use_for_ai": true,
      "tags": [
        "network_security",
        "arp_spoofing",
        "intrusion_detection",
        "packet_sniffing",
        "python",
        "scapy",
        "wireshark",
        "bash",
        "networking",
        "automation"
      ],
      "summary": "Python/Scapy ARP spoof detector with packet inspection, MAC/IP verification, and Wireshark-friendly logging.",
      "title": "ARP Spoof Detector"
    },
    "content": "\n# ARP Spoof Detector ‚Äî Python-Based Network Security Tool  \n\n## Overview\n\nThe **ARP Spoof Detector** is a Python-based defensive security tool that monitors a local network for\n**ARP poisoning** attacks. ARP spoofing is a common technique used to:\n\n- intercept traffic (Man-in-the-Middle attacks)  \n- disrupt network connectivity  \n- impersonate gateway or device IPs  \n\nThis tool continuously scans ARP packets, identifies suspicious MAC/IP mismatches, and alerts the user\nin real time.\n\nIt demonstrates:\n\n- network traffic analysis  \n- ARP protocol understanding  \n- attack detection logic  \n- practical cybersecurity engineering  \n\n## Problem Statement\n\nIn ARP spoofing:\n\n- an attacker sends false ARP replies  \n- associates their MAC with a victim‚Äôs IP address  \n- reroutes or intercepts traffic  \n\nMost devices never verify ARP messages, making the LAN vulnerable.\n\nThe goal of this project:\n\n- detect ARP spoof events quickly  \n- verify MAC/IP relationships  \n- warn the user immediately  \n- run efficiently on typical local networks  \n\n## System Architecture\n\n```\nNetwork Traffic ‚Üí Packet Sniffer ‚Üí ARP Analyzer ‚Üí MAC Verification ‚Üí Alert System\n```\n\n### Components\n\n1. **Packet Sniffer**  \n   - Uses `scapy` in Python  \n   - Listens for ARP ‚Äúwho-has‚Äù and ‚Äúis-at‚Äù packets  \n\n2. **MAC Verification Engine**  \n   - Maintains a trusted MAC‚ÄìIP mapping table  \n   - Detects changes or inconsistencies  \n\n3. **Spoof Detection Logic**\n   - Identifies if two different MAC addresses claim the same IP  \n   - Flags if gateway IP is claimed by a non-gateway MAC  \n\n4. **Alert System**\n   - Console warnings  \n   - Optional logging  \n   - Optional email/SMS alerts (extensible)\n\n## Implementation Details\n\n### Packet Sniffing\n\nUsing Scapy:\n\n```python\nfrom scapy.all import sniff, ARP\n\ndef sniff_packets():\n    sniff(store=False, prn=analyze_packet, filter=\"arp\")\n```\n\n### ARP Analysis Logic\n\n```python\ndef analyze_packet(pkt):\n    if pkt.haslayer(ARP) and pkt[ARP].op == 2:  # ARP Reply\n        ip = pkt[ARP].psrc\n        mac = pkt[ARP].hwsrc\n\n        if ip in ip_mac_table and ip_mac_table[ip] != mac:\n            alert(ip, ip_mac_table[ip], mac)\n        else:\n            ip_mac_table[ip] = mac\n```\n\n### Spoof Detection Conditions\n\n- **Condition A:** Same IP seen with two different MACs  \n- **Condition B:** Gateway IP claimed by an unknown MAC  \n- **Condition C:** MAC address appears on sudden multiple IPs  \n\n### Alert Function\n\n```python\ndef alert(ip, original_mac, spoofed_mac):\n    print(f\"[!] Possible ARP Spoof Detected:\")\n    print(f\"    IP Address: {ip}\")\n    print(f\"    Original MAC: {original_mac}\")\n    print(f\"    Detected MAC: {spoofed_mac}\")\n```\n\n### Performance Considerations\n\n- Real-time detection with low CPU usage  \n- Works on Wi-Fi and Ethernet  \n- No need for packet storage ‚Üí memory efficient  \n\n## Results\n\n- Successfully detects ARP spoof attempts in real networks  \n- Works immediately on common networks without special setup  \n- Detects gateway spoofing (most dangerous case)  \n- Minimal system resource usage  \n- Easy to extend into a full IDS module  \n\n## Skills Demonstrated\n\n- Python networking  \n- Packet sniffing using Scapy  \n- Understanding ARP protocol internals  \n- Intrusion detection logic  \n- Pattern recognition for MAC/IP inconsistencies  \n- Practical cybersecurity tooling  \n\n## Narration / Reflection\n\nBuilding this tool gave me hands-on insight into how simple but dangerous ARP spoofing is on typical\nnetworks. It reinforced:\n\n- the importance of validating assumptions in protocols  \n- how fragile local network trust systems can be  \n- how lightweight detection can significantly improve security  \n\nThis project strengthened my ability to think like both an attacker **and** a defender ‚Äî a skill that later\nhelped in debugging complex system interactions across networking, DSP, and embedded domains.\n\n---\n"
  },
  {
    "id": "projects/beatnik-osc-glove/index.md",
    "collection": "projects",
    "slug": "beatnik-osc-glove",
    "url": "/projects/beatnik-osc-glove/",
    "word_count": 742,
    "data": {
      "visibility": "public",
      "use_for_ai": true,
      "title": "Beatnik ‚Äî Gesture-Controlled OSC/MIDI Glove",
      "summary": "Hand-gesture OSC glove with piezo/FSR sensing, active analog filtering, and DMA-driven MCU output. Interfaced with Ableton Live.",
      "year": "Prototype",
      "format": "Project Archive",
      "code": "HCI-05",
      "cover_image": "https://images.unsplash.com/photo-1492684223066-81342ee5ff30?q=80&w=1000&auto=format&fit=crop",
      "tags": [
        "gesture_control",
        "osc",
        "midi",
        "sensors",
        "embedded",
        "dma",
        "piezo_sensing",
        "stm32",
        "c",
        "ableton_live"
      ],
      "article_slug": "beatnik-osc-glove"
    },
    "content": "\n# BEATNIK ‚Äì Gesture-Controlled OSC/MIDI Glove  \n\n## Overview\n\nBEATNIK is a wearable glove-based controller that converts gestures and finger movements into:\n\n- **OSC (Open Sound Control) messages**, and  \n- **MIDI notes / MIDI Control Change messages**\n\nIt enables expressive performance control for:\n\n- synthesizers  \n- DAWs (Ableton, Logic, FL Studio)  \n- modular synthesis environments (Max/MSP, SuperCollider, Pure Data)  \n- VST plugins and live performance rigs  \n\nThe system integrates:\n\n- flex sensors  \n- IMU/accelerometer  \n- embedded C firmware  \n- OSC/MIDI communication  \n- host-side sound engines  \n\nIts goal is to provide **fluid, human, gestural music control** that traditional knobs/sliders cannot offer.\n\n## Problem Statement\n\nMost music controllers:\n\n- are discrete  \n- rely on buttons/knobs  \n- lack expressive nuance  \n- feel mechanical rather rather than human  \n\nBEATNIK enables **natural, continuous, real-time control** using gestures.\n\nChallenges solved:\n\n- stable sensor readings under noise  \n- low-latency gesture detection  \n- expressive mapping to MIDI/OSC  \n- intuitive interface for performers  \n\n## System Architecture\n\n### Hardware Layer\n- Flex sensors (1 per finger)\n- IMU/accelerometer for tilt / roll / shake\n- Microcontroller (Arduino/Teensy class)\n\n### Signal Processing Layer\n- ADC sampling  \n- Exponential smoothing to reduce jitter  \n- Gesture classification  \n- Noise thresholding  \n\n### OSC & MIDI Output Layer\n- OSC message packer  \n- MIDI note generator  \n- MIDI CC mapping  \n- Configurable output mode (OSC-only, MIDI-only, hybrid)\n\n### Host System\n- DAW or synthesis environment that receives OSC or MIDI  \n\n## OSC Messaging (Full Technical Detail)\n\nOSC messages follow a structured namespace:\n\n```\n/beatnik/finger1      float 0.0‚Äì1.0\n/beatnik/finger2      float 0.0‚Äì1.0\n/beatnik/finger3      float 0.0‚Äì1.0\n/beatnik/finger4      float 0.0‚Äì1.0\n/beatnik/finger5      float 0.0‚Äì1.0\n\n/beatnik/tilt         float -1.0‚Äì1.0\n/beatnik/roll         float -1.0‚Äì1.0\n/beatnik/shake        float 0‚Äì127\n```\n\n### OSC Uses\n- Flex ‚Üí filter cutoff, LFO depth, amplitude envelope  \n- Tilt ‚Üí pitch bend or spatialization  \n- Shake ‚Üí percussive trigger or FX burst  \n\n### OSC Rate\n- Sent at **30‚Äì60 Hz** for smooth motion without overloading host apps  \n\n## MIDI Note + CC Messaging (Full Detail)\n\nThe glove supports three musical modes:\n\n### MIDI Note Triggering\nEach finger can trigger notes:\n\n| Finger Gesture | Threshold | MIDI Output |\n|----------------|-----------|-------------|\n| Index bent     | > bend_t  | NOTE ON 60 velocity=X |\n| Index released | < bend_t  | NOTE OFF 60 |\n| Middle bent    | > bend_t  | NOTE ON 62 |\n| Ring bent      | ‚Ä¶         | NOTE ON 64 |\n\n### Velocity Calculation\n```\nvelocity = clamp( (Œîfinger_bend / Œît) * 127 )\n```\n\nThis creates **human feel** rather than fixed velocity.\n\n### MIDI CC Control (Continuous Control)\n\nRecommended mappings:\n\n```\nfinger1 ‚Üí CC74 (Filter Cutoff)\nfinger2 ‚Üí CC1  (Mod Wheel / Vibrato)\nfinger3 ‚Üí CC11 (Expression)\ntilt    ‚Üí CC10 (Pan)\nshake   ‚Üí CC5  (Portamento or FX depth)\n```\n\nGestures map to CC values **0‚Äì127**.\n\n### Pitch Bend\nTilt angle ‚Üí bend value:\n\n```\npitchbend = map(tilt, -1.0..1.0 ‚Üí -8192..8191)\n```\n\n### Supported Output Modes\n\n| Mode | Behavior |\n|------|----------|\n| OSC-only | Continuous OSC messages only |\n| MIDI-only | Notes + CC only |\n| Hybrid | Sends both OSC + MIDI for experimental rigs |\n\n## Implementation Details\n\n### Firmware (C)\n- ADC sampling loop  \n- Normalization of sensor values  \n- Exponential smoothing filter  \n- State machine for gesture detection  \n- OSC packing (Lightweight OSC library)  \n- MIDI over USB or serial  \n\n### Latency Optimization\n- Non-blocking timing loops  \n- Minimal filtering delay (<5 ms)  \n- Efficient OSC batching  \n- USB MIDI for ultra-low latency  \n\n### Host Setup\nCompatible with:\n- Ableton Live (via virtual MIDI port or OSC bridge)\n- Max/MSP patches\n- SuperCollider SynthDefs\n- Logic Pro (MIDI layer)\n- Pure Data & VCV Rack (OSC)\n\n## Results\n\n- Very expressive modulation (filter/fx sweeps)  \n- Stable continuous CC values  \n- Clean note triggering  \n- <20 ms total end-to-end latency  \n- Natural gestural performance experience  \n\n## Skills Demonstrated\n\n- Embedded C  \n- Sensor fusion  \n- Real-time filtering  \n- OSC protocol implementation  \n- MIDI generation  \n- Human‚Äìcomputer interaction  \n- Hardware‚Äìsoftware integration  \n\n## Narration / Reflection\n\nThis project showed me how raw movement becomes **musical performance**.\n\nI learned that:\n\n- sensor data is noisy and must be shaped,  \n- expressiveness requires continuous control,  \n- OSC and MIDI each offer unique strengths,  \n- real-time systems must feel responsive, not only correct.\n\nBEATNIK taught me to think from the **performer's perspective**, not just the engineer‚Äôs.  \nIt shaped my sensitivity to latency, gesture dynamics, and expressive control ‚Äî skills that later influenced\nmy DSP and audio engineering work.\n\n---\n"
  },
  {
    "id": "projects/dtmf_detector/index.md",
    "collection": "projects",
    "slug": "dtmf_detector",
    "url": "/projects/dtmf_detector/",
    "word_count": 9,
    "data": {
      "visibility": "public",
      "use_for_ai": true,
      "title": "DTMF Detector ‚Äî Goertzel-Based DSP Project",
      "tags": [
        "dsp",
        "goertzel",
        "dtmf",
        "telephony",
        "embedded",
        "c",
        "real_time",
        "signal_processing",
        "stm32",
        "testing"
      ],
      "summary": "Goertzel-based DTMF detector on STM32/C with real-time tone validation, debouncing, and test coverage."
    },
    "content": "\n# DTMF Detector ‚Äî Goertzel-based DSP Project\n"
  },
  {
    "id": "projects/laser-harp/index.md",
    "collection": "projects",
    "slug": "laser-harp",
    "url": "/projects/laser-harp/",
    "word_count": 593,
    "data": {
      "visibility": "public",
      "use_for_ai": true,
      "title": "Laser Harp ‚Äî Optical Motion-Based Musical Instrument",
      "summary": "Laser-triggered MIDI controller using photodiodes and serial comms to drive performance hardware. Built on PIC Microcontroller.",
      "year": "Instrument",
      "format": "Project Archive",
      "code": "INS-06",
      "cover_image": "https://images.unsplash.com/photo-1535905557558-afc4877a26fc?q=80&w=1000&auto=format&fit=crop",
      "tags": [
        "laser",
        "optics",
        "embedded",
        "sensors",
        "musical_interface",
        "midi",
        "photodiodes",
        "c",
        "analog_filtering",
        "calibration"
      ],
      "article_slug": "laser-harp"
    },
    "content": "\n# Laser Harp ‚Äî Optical Motion-Based Musical Instrument  \n\n## Overview\n\nThe **Laser Harp** is an optical musical instrument where each ‚Äústring‚Äù is a **beam of laser light**.  \nWhen a performer moves their hand through a beam, the interruption is detected and translated into a:\n\n- **MIDI note**,  \n- **OSC message**, or  \n- **control signal**  \n\ndepending on the chosen output mode.\n\nThe project combines:\n\n- real-time embedded sensing  \n- optical alignment and calibration  \n- noise filtering  \n- musical mapping logic  \n- gestural control concepts  \n\n## Problem Statement\n\nPhysical harps require string plucking.  \nThe goal here was to design a **touchless**, visually striking instrument that:\n\n- reacts instantly to hand motion  \n- avoids false triggers from ambient light  \n- maps gestures to musical notes cleanly  \n- is playable in low and high lighting conditions  \n\nChallenges solved:\n\n- optical noise from room lighting  \n- sensor threshold calibration  \n- fast detection of beam interruption  \n- avoiding note flicker and retriggers  \n- mapping multiple beams to a musical scale  \n\n## System Architecture\n\n### Optical Beam System\n- Multiple laser diodes positioned vertically  \n- Photodiodes or LDRs aligned opposite each laser  \n- A constant laser ‚Üí photodiode reading indicates ‚Äúbeam intact‚Äù  \n- A drop in sensor voltage indicates ‚Äúbeam broken‚Äù  \n\n### Signal Conditioning\nTo create stable digital-like signals:\n\n- Analog low-pass filters  \n- Comparator circuits for thresholding  \n- Pull-up/pull-down stabilization  \n- Shielding to reduce ambient noise  \n\n### Embedded Controller\nA microcontroller (Arduino/Teensy-level) handled:\n\n- Reading photodiode outputs  \n- Applying debounce logic  \n- State transitions (INTACT ‚Üí BROKEN ‚Üí INTACT)  \n- Generating MIDI/OSC messages  \n\n### Output Layer\nSupports three modes:\n\n#### MIDI Mode\n- Note ON when the beam is broken  \n- Note OFF when the beam is restored  \n- Notes mapped to diatonic or chromatic scales  \n\n#### OSC Mode\n- OSC messages for:\n  ```\n  /laserharp/string1\n  /laserharp/string2\n  /laserharp/string3\n  ```\n- Useful for synthesis engines like Max/MSP, Pure Data, SuperCollider  \n\n#### Hybrid Mode\n- Both OSC + MIDI for advanced performance rigs  \n\n## Implementation Details\n\n### Photodiode Alignment\n- Required precise beam-to-sensor alignment  \n- Beam intensity adjusted to prevent oversaturation  \n- Ambient light tested in different environments  \n\n### Embedded Logic (C)\nThe core loop ran at a stable frequency:\n\n```c\nif (sensor_value < threshold && state == INTACT) {\n    trigger_note(string_id);\n    state = BROKEN;\n}\n\nif (sensor_value > threshold && state == BROKEN) {\n    release_note(string_id);\n    state = INTACT;\n}\n```\n\nAdditional logic:\n\n- Software debounce  \n- Minimum-hold timers  \n- Velocity/glide options  \n\n### MIDI Note Mapping\nTwo options:\n\n#### Fixed Scale\n```\nBeam 1 ‚Üí MIDI 60 (C4)\nBeam 2 ‚Üí MIDI 62 (D4)\nBeam 3 ‚Üí MIDI 64 (E4)\n```\n\n#### Dynamic Mode\nPitch determined by:\n\n- hand height  \n- beam index  \n- external scale tables  \n\n### OSC Mapping\nExample:\n\n```\n/harp/beam1 1   ‚Üí beam broken\n/harp/beam1 0   ‚Üí beam restored\n```\n\n## Results\n- Intuitive and fun to play  \n- Clear on/off triggering with minimal jitter  \n- Visually striking, ideal for performance  \n- Low latency due to efficient embedded design  \n\n## Skills Demonstrated\n- Embedded C development  \n- Analog/digital signal conditioning  \n- Real-time state machine implementation  \n- MIDI and OSC output design  \n- Hardware prototyping  \n- UX design for interactive instruments  \n\n## Narration / Reflection\nBuilding a **touchless optical instrument** taught me how environmental factors, noise, timing stability, \nand physical placement influence real-time interaction.  \n\nA laser harp only feels ‚Äúcorrect‚Äù when triggering is instantaneous and stable.  \nThis reinforced principles that later shaped my DSP and audio engineering mindset:\n\n- responsiveness matters  \n- noise must be controlled  \n- thresholds require tuning  \n- UX is just as important as code  \n\n---\n"
  },
  {
    "id": "projects/massive_mimo_seminar/index.md",
    "collection": "projects",
    "slug": "massive_mimo_seminar",
    "url": "/projects/massive_mimo_seminar/",
    "word_count": 301,
    "data": {
      "visibility": "restricted",
      "use_for_ai": false,
      "tags": [
        "wireless",
        "mimo",
        "linear_precoding",
        "sdr",
        "beamforming",
        "channel_modeling",
        "matlab",
        "mmwave",
        "research",
        "link_budget"
      ],
      "summary": "Academic seminar on massive MU-MIMO downlink: linear precoding, beamforming pilots, achievable rates, and MATLAB simulations.",
      "title": "Massive MU-MIMO Seminar"
    },
    "content": "\n# Academic Seminar ‚Äì Massive MU-MIMO Downlink with Linear Precoding and Downlink Pilots  \n\n## Overview\n\nThis seminar explored **Massive Multi-User MIMO** in TDD systems with a focus on:\n\n- Linear precoding (MRT, ZF)  \n- CSI acquisition  \n- Beamforming-based downlink training  \n- Achievable rate analysis  \n- MATLAB simulations  \n\nThis was an **academic research seminar**, not industry work, and provides foundational understanding of \nmulti-antenna wireless systems.\n\n## Problem Statement\n\nMassive MIMO systems achieve high spectral efficiency using many antennas (M >> K), but face:\n\n- CSI acquisition challenges  \n- Pilot overhead  \n- Inter-user interference  \n- Precoding complexity  \n\nThe goal was to evaluate practical training schemes and achievable rate bounds under realistic constraints.\n\n## System Components\n\n- TDD reciprocity  \n- MMSE channel estimation  \n- Orthogonal pilot sequences  \n\n### Downlink Beamforming Pilots\nBeamformed pilots help users estimate **effective channel gain**, reducing overhead from M to K.\n\n### Linear Precoding\n- **MRT (Maximum Ratio Transmission)**  \n  - Simple, high SNR behavior  \n  - Poor interference suppression  \n\n- **ZF (Zero-Forcing)**  \n  - Better interference handling  \n  - Requires more accurate CSI  \n\n### Achievable Rate Analysis\nAnalytical lower bounds computed for both precoding schemes.\n\n## MATLAB Simulations\n\nSimulated:\n- Spectral efficiency vs SNR  \n- MRT vs ZF comparison  \n- Genie-aided receiver benchmarks  \n- Varying coherence intervals  \n- Impact of imperfect CSI  \n\nFindings:\n- ZF outperforms MRT in multi-user settings  \n- Beamforming training reduces pilot overhead significantly  \n- Longer coherence intervals improve achievable rates  \n\n## Skills Demonstrated\n\n- Wireless system modeling  \n- MATLAB simulation  \n- Linear algebra for communication systems  \n- Reading and summarizing research papers  \n- Understanding spectral efficiency bounds  \n\n## Narration\n\nThis seminar gave me foundational insight into how large-scale antenna systems operate.\nAlthough I don‚Äôt specialize in Massive MIMO professionally, the experience strengthened my confidence \nin analyzing complex communication systems, which later supported my DSP and engineering mindset.\n"
  },
  {
    "id": "projects/multihop_wireless_warp_prototyping/index.md",
    "collection": "projects",
    "slug": "multihop_wireless_warp_prototyping",
    "url": "/projects/multihop_wireless_warp_prototyping/",
    "word_count": 619,
    "data": {
      "visibility": "public",
      "use_for_ai": true,
      "title": "Multi-Hop Wireless Prototyping with WARP SDR",
      "tags": [
        "wireless",
        "sdr",
        "matlab",
        "multi_hop",
        "cooperative_relays",
        "ofdm",
        "channel_modeling",
        "warp",
        "synchronization",
        "link_budget"
      ],
      "summary": "WARP SDR multi-hop prototype with MATLAB tooling for packet tracing, channel modeling, and cooperative relay experiments."
    },
    "content": "\n# Multi-Hop Wireless Prototyping with WARP SDR  \n\n## Overview\n\nThis project involved building a **research-grade multi-hop wireless prototyping system** using:\n\n- **WARP SDR boards**  \n- **MATLAB visualization tools**  \n- **Custom data parsing and analysis scripts**\n\nThe aim was to allow researchers and students to **see and understand** how packets propagate through\nmulti-hop and cooperative communication networks under real wireless conditions.\n\nThe project unified:\n\n- SDR experimentation  \n- Wireless communication theory  \n- Data visualization  \n- MATLAB GUI development  \n- Research methodology  \n\n## Problem Statement\n\nMulti-hop wireless networks behave far differently in practice than in theoretical models.  \nDifficulties include:\n\n- unpredictable packet drops  \n- timing misalignments between relays  \n- asymmetric link quality  \n- non-intuitive hop progression  \n- unclear forwarding behaviors in coded vs. uncoded relays  \n\nRaw logs alone make these behaviors **very hard to understand**.\n\nResearchers needed:\n\n‚úî A visualization tool  \n‚úî Real-time or near-real-time feedback  \n‚úî Clear multi-hop path reconstruction  \n‚úî Comparison between forwarding schemes  \n\n## System Architecture\n\n### WARP SDR Nodes\nRoles included:\n- Source  \n- One or more relays  \n- Destination  \n\nNodes were configured to run experiments on cooperative relaying and multi-hop forwarding.\n\n### Experiment Logging\nEach WARP node logged:\n- packet arrivals  \n- MAC/PHY timing  \n- hop counts  \n- relay decisions  \n- RSSI / link quality indicators  \n\n### MATLAB Data Interface\nA MATLAB module was written to:\n- import logs  \n- parse timestamps  \n- synchronize node records  \n- reconstruct packet paths  \n- compute per-hop statistics  \n\n### MATLAB Visualization GUI\nCustom GUI displayed:\n- node topology  \n- live or replayed packet flow  \n- hop progression animation  \n- RSSI bars  \n- coded vs. uncoded performance difference  \n- timelines and link behavior  \n\n## Implementation Details\n\n### MATLAB Parsing Logic\n- Parsed CSV/log files from each node  \n- Mapped packet IDs ‚Üí forwarding chain  \n- Detected losses and duplicates  \n- Aligned timestamps across nodes  \n- Constructed directed graphs of packet movement  \n\n### GUI Modules\n- **Topology View**: nodes arranged visually, routing lines updated dynamically  \n- **Hop Timeline**: how many hops a packet took across time  \n- **RSSI Panel**: color-coded link quality  \n- **Per-packet Playback**: replay packet propagation step-by-step  \n\n### SDR Experiment Configuration\n- Configured transmit power  \n- Selected carrier frequency  \n- Adjusted PHY parameters  \n- Collected logs in controlled and noisy environments  \n\n### Data Analysis Scripts\n- computed per-hop success rates  \n- compared coded vs uncoded forwarding reliability  \n- plotted latency distributions  \n- identified link asymmetries  \n\n## Key Findings\n\nThe visualization revealed behaviors that were NOT obvious from theory:\n\n- **Relay‚Äìdestination links behaved asymmetrically**, causing unexpected drops  \n- **Coded forwarding improved robustness**, especially under low SNR  \n- **Timing misalignment** between relays caused packet duplication or premature discard  \n- **Hop count fluctuated dynamically**, depending on the wireless environment  \n\nGraphs and animations provided immediate intuition about the multi-hop behavior that traditional logs\nand equations could not convey.\n\n## Skills Demonstrated\n\n### Wireless Communication Engineering\n- Understanding of multi-hop and cooperative relaying  \n- SDR hardware handling  \n- Wireless measurement interpretation  \n\n### MATLAB Engineering\n- GUI development  \n- Data parsing / cleaning  \n- Signal visualization  \n- Experiment automation  \n\n### Research Workflow Skills\n- Experiment design  \n- Interpretation of real channel behaviors  \n- Presenting wireless concepts visually  \n\n### Systems Thinking\n- Bridging hardware measurements ‚Üí interpretable information  \n- Making complex wireless behavior intuitive  \n\n## Narration / Reflection\n\nThis project was my first experience in turning **raw wireless behavior** into **visual insight**.\n\nI realized:\n\n- Real channels don‚Äôt behave like textbook channels  \n- Logs are meaningless without visualization  \n- Timing mismatches and asymmetric links dominate multi-hop performance  \n- Visualization accelerates research understanding dramatically  \n\nThe project strengthened my skills in combining **engineering rigor**, **experimental thinking**, and \n**visual communication**, which later translated directly into how I approach debugging and system\nanalysis in DSP and audio engineering.\n\n---\n"
  },
  {
    "id": "projects/my-live-portfolio/index.md",
    "collection": "projects",
    "slug": "my-live-portfolio",
    "url": "/projects/my-live-portfolio/",
    "word_count": 917,
    "data": {
      "visibility": "public",
      "use_for_ai": true,
      "title": "My Live Portfolio ‚Äî VHS",
      "summary": "A living tape about why I turned my career into an adaptive portfolio instead of a flat PDF‚Äîhumorous, reflective, and stubbornly alive.",
      "year": "Personal System",
      "format": "Project Archive",
      "code": "VHS-09",
      "cover_image": "https://images.unsplash.com/photo-1516116216624-53e697fedbea?q=80&w=1000&auto=format&fit=crop",
      "tags": [
        "portfolio",
        "web_design",
        "javascript",
        "css",
        "html",
        "accessibility",
        "writing",
        "branding",
        "ai",
        "storytelling"
      ],
      "article_slug": "my-live-portfolio"
    },
    "content": "\n‚∏ª\n\nüéû My Live Portfolio\n\nWhy I Turned My Career Into a Living System Instead of a PDF\n\n‚∏ª\n\nVHS INTRO\n\nThis tape contains the story behind one of my most personal projects: My Live Portfolio.\nIt‚Äôs not a technical breakdown. It‚Äôs the ‚Äúwhy‚Äù ‚Äî the honest, slightly funny journey that started when I realised my CV no longer matched the person I‚Äôve actually become.\n\nPress play to enter the archives of my own professional confusion and rediscovery.\n\n‚∏ª\n\nMy Live Portfolio ‚Äî The Article (Polished Version)\n\nI didn‚Äôt create this project because I needed another fancy section on a website.\nI created it because, after years of working, I discovered something mildly disturbing:\n\nMy CV had become a stranger.\n\nThe titles were correct.\nThe job descriptions were accurate.\nThe bullet points looked well-behaved.\n\nBut the real substance of my work ‚Äî the problems I solved, the systems I built, the mistakes I learned from, the ideas that actually shaped me ‚Äî none of that existed on paper. Everything felt flattened and dehydrated. My career looked like an over-compressed audio file: recognisable, but missing all the richness.\n\nThe strangest part wasn‚Äôt that others couldn‚Äôt see it.\nThe strangest part was that I had forgotten half of it too.\n\n‚∏ª\n\n## When a PDF stops being enough\n\nIt hit me when I tried to ‚Äúproperly update‚Äù my CV.\nScrolling through old sections, I realised I had to think hard just to remember certain projects I once worked on daily. Technical decisions I made confidently back then were now blurry details buried under years of new responsibilities.\n\nThat‚Äôs when it clicked:\nA CV is not a portrait.\nIt‚Äôs a passport photo ‚Äî flat, tiny, and only vaguely similar to the real person.\n\nI didn‚Äôt want to be represented by something that forgettable.\n\n‚∏ª\n\n## Excavating my own past\n\nBefore anything became a project, it became an excavation.\n\nI opened old internship reports, thesis documents, job folders, research notes, side projects, random screenshots, and files with suspicious names like ‚Äúfinal_v3_realfinal_OK.pdf‚Äù. Some of it made me laugh. Some of it made me nostalgic. Some of it made me wonder how I ever did those things and then just‚Ä¶ moved on.\n\nBut the more I organised, the more overwhelming it became.\nA mountain of content is still a mountain.\n\nIf I tried to dump all of it onto a webpage, no one would read it.\nNot even me.\n\nOrganisation alone wasn‚Äôt enough.\nI needed something that could make sense of it.\n\n‚∏ª\n\n## What if my career could actually respond?\n\nThis was the moment the idea sharpened.\n\nInstead of juggling 15 versions of a CV or writing summaries for every purpose, I wondered:\n\nWhat if my portfolio could adapt?\nWhat if it could answer different questions?\nWhat if it could tell different stories based on what someone needs to know?\n\nWhat if it could link past work to future goals, without me manually rewriting everything?\n\nBasically:\nWhat if my career could talk back?\n\nThat‚Äôs how the idea of a Live Portfolio came to life ‚Äî a system that doesn‚Äôt display my work, but understands it.\n\n‚∏ª\n\n## The honest human motivation\n\nLet‚Äôs be direct.\nPart of this project is absolutely me refusing to let anyone judge my entire engineering life in eight seconds of CV scanning.\n\nThe other part is personal: I don‚Äôt want to forget who I became through all these years. Skills fade when they aren‚Äôt revisited. Memories blur. Achievements shrink when squeezed between bullet point formatting.\n\nI realised I needed something alive ‚Äî something that grows with me, remembers for me, and helps me articulate my own capabilities with clarity, not guesswork.\n\n‚∏ª\n\n## Then the engineer in me took over\n\nEmotions got me started, but systems thinking finished the idea.\n\nI began treating my career like an engineering problem:\n\t‚Ä¢\tRaw data: documents, projects, roles, timelines\n\t‚Ä¢\tStructure: skills, tags, technologies, responsibilities\n\t‚Ä¢\tMeaning: what these experiences actually say about me\n\t‚Ä¢\tOutputs: narratives for specific situations\n\t‚Ä¢\tInterface: simple, natural, adaptable\n\nIt‚Äôs basically an encoder for my professional identity:\n\nInput ‚Üí messy but meaningful journey\nOutput ‚Üí tailored, coherent, human explanations\n\nThis felt more ‚Äúme‚Äù than any CV I had ever written.\n\n‚∏ª\n\n## What My Live Portfolio really is\n\nIt is:\n\t‚Ä¢\tA rebellion against being reduced to two pages\n\t‚Ä¢\tA system that keeps my work alive instead of archived\n\t‚Ä¢\tA tool that helps me understand myself as much as others understand me\n\t‚Ä¢\tA way to tell richer stories without overwhelming people\n\t‚Ä¢\tA personal reminder of everything I‚Äôve built and learned\n\t‚Ä¢\tA project that grows as I continue evolving\n\nBut most of all, it‚Äôs an honest attempt to represent myself properly ‚Äî not as a static document, but as an ongoing story.\n\n‚∏ª\n\nVHS OUTRO\n\nTape ends here.\nThe emotional journey is complete.\n\nIf you‚Äôre curious about the technical machinery behind My Live Portfolio ‚Äî the data models, the structure, the AI logic ‚Äî that‚Äôs on a separate tape in the archive.\nThis one was never about the system. It was about the person building it.\n\n‚∏ª\n\nBack-Cover Summary\n\nA reflective and slightly humorous story about why I built My Live Portfolio. After years of work compressed into a lifeless CV, I went back through my past, rediscovered forgotten projects, and realised I needed a living system that understands and expresses my career in a way a PDF never could. This article is the story behind that decision.\n\n‚∏ª\n"
  },
  {
    "id": "projects/parallel-av-encoding-framework/index.md",
    "collection": "projects",
    "slug": "parallel-av-encoding-framework",
    "url": "/projects/parallel-av-encoding-framework/",
    "word_count": 165,
    "data": {
      "visibility": "public",
      "use_for_ai": true,
      "title": "Parallel A/V Encoding Framework",
      "summary": "Concurrent FFmpeg + Python harness for ABR ladder experimentation with metrics and packaging.",
      "tags": [
        "ffmpeg",
        "python",
        "encoding",
        "abr",
        "metrics",
        "bash",
        "automation",
        "packaging",
        "streaming",
        "monitoring"
      ]
    },
    "content": "\n# Building an ABR Encoding Lab\n\nNeeded: explore encoder variants quickly, measure quality, and assemble ladder candidates without hand-running FFmpeg every time. Built a Python + FFmpeg harness that ingests, fragments, runs variants, and spits out HLS/DASH artifacts with consistent logging.\n\n‚∏ª\n\n## Ingest & fragment\n- Auto-detect inputs, normalize tracks, segment into fragments with stable GOP alignment.\n- Write fragment manifests so every variant keeps matching metadata.\n\n## Concurrent runs\n- Spawn FFmpeg workers across cores; track PIDs, timeouts, per-job temp dirs.\n- Sweep GOP, tune/preset, RC mode, filters; produce fragmented MP4s per variant.\n- Concatenate select fragments into short A/B clips for quick playback checks.\n\n## Metrics & packaging\n- Generate HLS/DASH playlists and ladders automatically from successful variants.\n- Log VMAF, PSNR, bitrate, throughput; export CSVs to compare size vs. quality.\n- Add guardrails: retries on transient failures, cleanup of orphaned processes, disk budget enforcement.\n\n## Outcome\nFaster ladder tuning with reproducible runs, instant A/B inspection, and clear quality/bandwidth trade-offs.\n"
  },
  {
    "id": "projects/parking_management_system/index.md",
    "collection": "projects",
    "slug": "parking_management_system",
    "url": "/projects/parking_management_system/",
    "word_count": 426,
    "data": {
      "visibility": "public",
      "use_for_ai": true,
      "tags": [
        "embedded",
        "sensors",
        "microcontroller",
        "parking_system",
        "real_time",
        "c",
        "firmware",
        "interrupts",
        "uart",
        "prototyping"
      ],
      "summary": "Embedded parking system in C with sensor polling, UART/display updates, and real-time slot tracking.",
      "title": "Intelligent Parking System"
    },
    "content": "\n# Intelligent Parking System ‚Äî Embedded C Project  \n\n## Overview\n\nThe **Intelligent Parking System** is an embedded project designed to detect parking slot occupancy in\nreal time using sensors and a microcontroller. The system reports free/occupied slots on a display and\ncan be extended for automated gate control or IoT integration.\n\nThis project demonstrates:\n\n- embedded C development  \n- real-time sensor polling  \n- decision logic  \n- LCD/LED display control  \n- hardware‚Äìsoftware integration  \n\n## Problem Statement\n\nParking spaces require:\n\n- clear visibility of available slots  \n- fast and reliable detection  \n- low-cost hardware  \n- stable operation under noise  \n\nTraditional systems rely on manual observation or expensive camera setups. The goal was to build a\nsimple, reliable embedded solution using basic sensors and microcontroller logic.\n\n## System Architecture\n\n### Components\n- Microcontroller (e.g., AVR, PIC, or Arduino-class)\n- Ultrasonic or IR sensors for vehicle detection\n- LCD/LED display module\n- Optional buzzer/indicator lights\n- Power regulation and wiring\n\n### Architecture Flow\n\n```\nSensors ‚Üí Microcontroller ‚Üí Decision Logic ‚Üí Display Output\n```\n\n### Detection Logic\n- Each sensor monitors a parking slot.\n- Sensor readings converted to digital occupancy state.\n- Microcontroller aggregates results and updates the display.\n\n## Implementation Details\n\n### Embedded C Logic\n\nKey functions:\n- Initialization of GPIO and sensor interfaces  \n- Continuous sampling loop  \n- Threshold-based detection  \n- Debounce and filtering to avoid false triggers  \n- Display update routines  \n\nExample pseudocode:\n\n```c\nif (distance < threshold && state == EMPTY) {\n    state = OCCUPIED;\n}\n\nif (distance > threshold && state == OCCUPIED) {\n    state = EMPTY;\n}\n```\n\n### Filtering & Stability\n- Simple moving average to reduce noise\n- Minimum-change thresholding\n- Timing delays to prevent rapid toggling\n\n### Display Output\n- Number of free slots\n- Visual indicators for each slot\n- Optional arrow signs or buzzer for user guidance\n\n## Results\n\n- Accurate detection in typical parking environments  \n- Low jitter after filtering  \n- Easy-to-read status output  \n- Low-cost hardware footprint  \n- Reliable operation under continuous polling  \n\n## Skills Demonstrated\n\n- Embedded C programming  \n- Sensor integration (IR/ultrasonic)  \n- Real-time signal filtering  \n- State-machine logic  \n- Display interfacing (LCD/LED)  \n- Debugging hardware‚Äìsoftware interactions  \n\n## Narration / Reflection\n\nThis project helped me understand how real-time embedded systems behave under real-world noise and\nsensor inconsistency. Building a robust detection pipeline taught me fundamentals of:\n\n- threshold tuning  \n- debounce strategies  \n- display synchronization  \n- embedded timing constraints  \n\nIt was one of the earliest projects where I saw how **simple sensing + reliable logic** can create a usable,\nreal-world system.\n\n---\n"
  },
  {
    "id": "projects/post-processing-separated-speech/index.md",
    "collection": "projects",
    "slug": "post-processing-separated-speech",
    "url": "/projects/post-processing-separated-speech/",
    "word_count": 658,
    "data": {
      "visibility": "public",
      "use_for_ai": true,
      "title": "Post-Processing Separated Speech",
      "summary": "Reconstructed damaged time-frequency components of separated speech using bandwidth extension. Analyzed LPC Analysis/Synthesis, STFT & Pitch Estimation, and Pole/Zero LPC Envelopes.",
      "year": "Master Thesis",
      "format": "Project Archive",
      "code": "DSP-01",
      "cover_image": "https://images.unsplash.com/photo-1518770660439-4636190af475?q=80&w=1000&auto=format&fit=crop",
      "tags": [
        "speech",
        "dsp",
        "bandwidth_extension",
        "lpc",
        "excitation",
        "speech_enhancement",
        "stft",
        "python",
        "matlab",
        "research"
      ],
      "article_slug": "post-processing-separated-speech"
    },
    "content": "\n# Master Thesis ‚Äî Speech Bandwidth Extension Using Non-Linear Post-Processing  \n\n## Overview\n\nThis thesis focused on reconstructing **wideband speech** from narrowband (telephone-band) input\nusing **non-linear post-processing**, **excitation modelling**, and **spectral envelope reconstruction**.\nThe goal was to increase perceived bandwidth, restore brightness, and improve naturalness **without**\nrequiring changes to the encoder or any side information.\n\nThe work brought together:\n\n- Digital signal processing theory (LPC, source‚Äìfilter models)\n- Practical system design\n- MATLAB & Python prototyping\n- Perceptual audio evaluation and tuning\n- Iterative refinement based on listening tests and spectral analysis\n\n## Problem Statement\n\nTraditional narrowband speech (0‚Äì4 kHz) loses:\n\n- High-frequency harmonics  \n- Brightness and ‚Äúair‚Äù  \n- Natural articulation cues  \n- Wideband timbral characteristics  \n\nThe challenge is reconstructing plausible high-band components **from missing information**, not noisy\ninformation. This is fundamentally an **ill-posed inverse problem**, requiring:\n\n- Excitation generation  \n- Envelope reconstruction  \n- Stability against artifacts  \n- Low computational cost  \n\nGoal:  \nProduce **wideband-like speech** that is perceptually convincing and spectrally coherent.\n\n## System Architecture\n\nThe thesis designed a processing chain consisting of:\n\n### Narrowband Analysis\n- Pre-emphasis  \n- Windowing  \n- LPC analysis (10‚Äì14th order)  \n- Extraction of the excitation signal  \n\n### Excitation Modelling\nTested approaches included:\n\n- Non-linear expansion  \n- Odd/even harmonic generation  \n- Sign-preserving power functions  \n- Spectral folding  \n- Blended excitation shaping  \n\nThe final system used **non-linear excitation expansion** with a **high-band shaping filter**.\n\n### Envelope Reconstruction\nMethods explored:\n\n- LPC envelope extrapolation  \n- High-band envelope smoothing  \n- Adaptive energy matching  \n- Band-tilting adjustments  \n\n### Synthesis\n- Excitation filtering using reconstructed LPC coefficients  \n- Overlap‚Äìadd synthesis  \n- Envelope smoothing and final spectral correction  \n\n## Block Diagram (Textual)\nNarrowband Speech\n‚Üì\nAnalysis\n(LPC, excitation)\n‚Üì\nNon-linear Excitation Expansion\n‚Üì\nHigh-band Spectral Shaping\n‚Üì\nEnvelope Reconstruction\n‚Üì\nSynthesis\n‚Üì\nEnhanced Wideband-like Speech\n\n## Implementation Details\n\n### MATLAB Prototyping\n- LPC extraction (autocorrelation & Burg methods)\n- Excitation expansion experiments\n- Envelope smoothing filters\n- Spectral envelope visualization\n- Objective metrics:\n  - log-spectral distance (LSD)\n  - harmonic envelope deviation\n\n### Python Experiments\n- Rapid testing of excitation functions\n- Plotting envelope differences\n- Generating spectrograms and comparison views\n- Automating batch evaluation sets\n\n## Evaluation Strategy\n\n### Objective Measures\n- High-band energy reconstruction accuracy  \n- Envelope shape similarity  \n- Temporal smoothness  \n\n### Perceptual Evaluation\nPerformed **A/B and A/B/X listening tests** on:\n\n- Male + female speech  \n- Different languages  \n- Varied articulation patterns  \n- Clean vs. challenging content  \n\nArtifacts tracked and tuned:\n\n- Metallic ringing  \n- Whistle-like tones  \n- Synthetic ‚Äúhiss‚Äù  \n- Harsh high-frequency energy  \n- Energy mismatch between narrowband and high-band  \n\n**Perceptual testing was essential** ‚Äî many methods that looked good numerically produced \nunacceptable artifacts during listening.\n\n## Key Results\n\n- Reconstructed high-band content **significantly improved** perceived brightness and clarity.  \n- Non-linear excitation + spectral shaping produced stable and natural-sounding results.  \n- High-band envelope reconstruction matched reference wideband behavior well.  \n- Objective and subjective evaluations aligned closely after tuning.\n\n## Skills Demonstrated\n\n### DSP Expertise\n- LPC modelling  \n- Excitation generation  \n- Non-linear processing  \n- Envelope shaping  \n- Filter design  \n- Time‚Äìfrequency analysis  \n\n### Prototyping Skills\n- MATLAB algorithm development  \n- Python batch experiments + visualization  \n- Handling multi-file evaluation pipelines  \n\n### Perceptual Engineering\n- Systematic listening test methodology  \n- Artifact identification  \n- Iterative tuning based on perceptual + spectral evidence  \n\n### Research & Documentation\n- Reproducible experiments  \n- Clear reporting of results  \n- Scientific and engineering communication  \n\n## Narration / Personal Reflection\n\nThis thesis shaped my understanding of audio engineering at a deep level.  \nI learned that:\n\n- A mathematically ‚Äúcorrect‚Äù algorithm may still sound terrible.  \n- Spectral plots, excitation behavior, and envelopes must align with what listeners perceive.  \n- Perceptual tuning is a **core part of DSP**, not an afterthought.  \n\nThe project taught me to think simultaneously like a:\n\n- **scientist** (theory, modelling)  \n- **engineer** (system design, prototyping)  \n- **listener** (perception, artifacts, tuning)  \n\nThis balance between **math, engineering, and human hearing** continues to define how I approach\naudio, DSP, and media systems today.\n\n---\n\n"
  },
  {
    "id": "projects/traffic_signal_controller/index.md",
    "collection": "projects",
    "slug": "traffic_signal_controller",
    "url": "/projects/traffic_signal_controller/",
    "word_count": 430,
    "data": {
      "visibility": "public",
      "use_for_ai": true,
      "tags": [
        "embedded",
        "microcontroller",
        "state_machine",
        "real_time",
        "c",
        "timers",
        "interrupts",
        "firmware",
        "prototyping",
        "testing"
      ],
      "summary": "Finite-state traffic light controller in C using timers/interrupts for deterministic, safe signal sequencing.",
      "title": "Traffic Signal Controller"
    },
    "content": "# Traffic Signal Controller ‚Äî Embedded C State Machine  \n\n## Overview\n\nThis project implements a **Traffic Signal Controller** using an embedded microcontroller and a  \n**finite state machine (FSM)**. The system handles:\n\n- red / yellow / green cycle timing  \n- safe state transitions  \n- pedestrian or extended-timing modes (optional)  \n- real-time light switching logic  \n\nIt demonstrates real-time embedded programming, state-machine design, and stable time-driven logic.\n\n## Problem Statement\n\nTraffic signals must operate:\n\n- predictably  \n- safely  \n- with strict timing control  \n- without glitches or ambiguous states  \n\nA naive implementation (e.g., delays or manual toggles) is unreliable.  \nA proper FSM is needed to ensure:\n\n- correct sequence ‚Üí Red ‚Üí Green ‚Üí Yellow ‚Üí Red  \n- timing consistency  \n- no illegal combinations  \n- clean reset behavior  \n\n## System Architecture\n\n### Hardware Components\n- Microcontroller (AVR / PIC / Arduino-class)\n- LED indicators:\n  - Red  \n  - Yellow  \n  - Green  \n- Timer module or software timer  \n- Optional input button (e.g., pedestrian mode)  \n\n### State Machine Diagram\n\n```\n      [RED]\n        |\n        v\n     [GREEN]\n        |\n        v\n     [YELLOW]\n        |\n        v\n      [RED]  (loop)\n```\n\n### State Definitions\n| State     | Lights Active         | Duration |\n|-----------|------------------------|----------|\n| RED       | Red ON                 | t_red    |\n| GREEN     | Green ON               | t_green  |\n| YELLOW    | Yellow ON              | t_yellow |\n\n## Implementation Details\n\n### FSM Structure (C)\n\n```c\nenum state { RED, GREEN, YELLOW };\nenum state current_state = RED;\n\nvoid loop() {\n    switch(current_state) {\n        case RED:\n            red_on(); green_off(); yellow_off();\n            wait(t_red);\n            current_state = GREEN;\n            break;\n\n        case GREEN:\n            green_on(); red_off(); yellow_off();\n            wait(t_green);\n            current_state = YELLOW;\n            break;\n\n        case YELLOW:\n            yellow_on(); red_off(); green_off();\n            wait(t_yellow);\n            current_state = RED;\n            break;\n    }\n}\n```\n\n### Timer Integration\n\n- Using hardware timers or non-blocking timing loops  \n- Ensures system remains responsive  \n\n### Optional Pedestrian Handling\n\n```c\nif (button_pressed() && safe_to_interrupt()) {\n    extend_red_phase();\n}\n```\n\n### Safety Guarantees\n\n- Never GREEN + RED at the same time  \n- Minimum time per state is enforced  \n- Guaranteed sequence order  \n- Optional emergency all-red mode  \n\n## Results\n\n- Smooth, predictable transitions  \n- Timing accuracy and stability  \n- Extensible to multi-intersection control  \n- No illegal LED combinations  \n- Reliable due to strict FSM structure  \n\n## Skills Demonstrated\n\n- Embedded C  \n- State machine design  \n- Real-time logic  \n- Timing systems  \n- IO interfacing  \n- Debugging embedded timing issues  \n\n## Narration / Reflection\n\nThis project taught me the importance of deterministic timing and clean control flow.  \nUsing a state machine made the behavior predictable and easy to reason about ‚Äî an approach that applies\nnot only to embedded systems but also to larger software and DSP pipelines.\n"
  },
  {
    "id": "projects/vidi/index.md",
    "collection": "projects",
    "slug": "vidi",
    "url": "/projects/vidi/",
    "word_count": 647,
    "data": {
      "visibility": "public",
      "use_for_ai": true,
      "title": "Vidi ‚Äî Low-Latency Pitch Tool",
      "summary": "Pitch detection and shifting across parametric and non-parametric methods. Built with iOS Core Audio, vDSP/Accelerate, and MIDI Mapping.",
      "year": "Audio Tool",
      "format": "Project Archive",
      "code": "APP-03",
      "cover_image": "https://images.unsplash.com/photo-1485846234645-a62644f84728?q=80&w=1000&auto=format&fit=crop",
      "tags": [
        "audio",
        "speech",
        "dsp",
        "pitch",
        "core_audio",
        "vDSP",
        "ios",
        "swift",
        "midi",
        "latency_optimization"
      ],
      "article_slug": "vidi"
    },
    "content": "\n# VIDI ‚Äî Low-Latency, Reliable Pitch Detection & Pitch-Shifting Tool  \n\n## Overview\n\n**VIDI** is a real-time pitch detection and pitch-shifting tool designed for musicians who need  \n**fast, stable, low-latency pitch tracking** ‚Äî even in noisy rooms or during rapid melodic passages.\n\nInstead of relying on a single pitch detection method, VIDI fuses multiple DSP techniques to provide\nconfidence-weighted pitch estimates that:\n\n- **lock quickly**,  \n- **don‚Äôt drift**,  \n- **remain stable under noise**, and  \n- **produce natural, musical pitch shifts** without chipmunk artifacts.\n\nIt was built with **Core Audio** and **vDSP**, optimized for **mobile-class hardware** with strict \nlatency and performance constraints.\n\n## Problem Statement\n\nMusicians need pitch tools that work **live**, not only in ideal studio conditions.  \nMost existing systems fail in at least one area:\n\n- too sensitive to noise  \n- unstable on fast notes  \n- slow lock-in time  \n- robotic or chipmunk-like pitch shifts  \n- MIDI output that drifts under load  \n\nVIDI solves these by combining multiple pitch algorithms and stabilizing them through DSP fusion.\n\n## System Architecture\n\n```\nIncoming Audio  \n      ‚Üì  \nFrame Processing (Core Audio)  \n      ‚Üì  \nParallel Pitch Estimators (AMDF / Autocorrelation / HPS)  \n      ‚Üì  \nConfidence Fusion Engine  \n      ‚Üì  \nFormant-Aware Pitch Shifting  \n      ‚Üì  \nLow-Latency MIDI Output  \n```\n\n## Key DSP Components\n\n### Parallel Pitch Detection Engines\n\nVIDI runs three pitch detectors concurrently:\n\n#### AMDF (Average Magnitude Difference Function)\n- Excellent for fast passages  \n- Good resolution for monophonic signals  \n- Works well in noisy conditions  \n\n#### Autocorrelation\n- Stable periodicity detection  \n- Helps reduce octave errors  \n- Provides reliable fundamentals  \n\n#### Harmonic Product Spectrum (HPS)\n- FFT-based approach using harmonic reinforcement  \n- Useful for strong harmonic structures  \n- Helps refine ambiguous pitch regions  \n\n### Confidence-Weighted Fusion\n\nResults are combined using a confidence score per method:\n\n- consistency across methods  \n- signal periodicity  \n- harmonic energy distribution  \n- AMDF minima stability  \n- autocorrelation peak clarity  \n\nThe fusion engine outputs a **single, stable pitch value** resistant to noise and instability.\n\n## Low-Latency Architecture\n\n### Core Audio + vDSP Pipeline\n\nVIDI uses:\n\n- **Core Audio render callbacks** for sub-10 ms frame processing  \n- **vDSP FFTs** for spectral methods  \n- Hot loop optimizations:\n  - inlining critical operations  \n  - avoiding unnecessary heap allocations  \n  - tight C loops for AMDF  \n  - vectorized operations where beneficial  \n\n### Performance Targets\n\n- **Frame size:** 64‚Äì128 samples  \n- **Latency budget:** configurable, typically 10‚Äì20 ms end-to-end  \n- **CPU footprint:** optimized for mobile processors  \n\n## Formant-Aware Pitch Shifting\n\nStandard pitch shifting introduces:\n\n- chipmunk vocals  \n- unnatural brightness  \n- timbre distortion  \n\nVIDI avoids this with:\n\n- **formant tracking**  \n- **spectral envelope estimation**  \n- **formant-preserving warping**  \n- blending PSOLA-like and phase-vocoder concepts  \n\nResult: **natural, human-sounding pitch shifts**, even at large intervals.\n\n## MIDI Output Engine\n\nVIDI generates highly stable MIDI output:\n\n- configurable smoothing  \n- hysteresis to reduce jitter  \n- velocity modeling based on onset detection  \n- guarantee of no timing drift under CPU load  \n\nCompatible with:\n\n- Ableton Live  \n- Logic Pro  \n- FL Studio  \n- Max/MSP  \n- Hardware synthesizers  \n\n## Results\n\nVIDI delivered:\n\n- **fast pitch lock-in**  \n- **stable tracking** even with noise  \n- **natural pitch shifts** without artifacts  \n- **low latency**, suitable for live use  \n- **accurate MIDI output**  \n\nMusicians rated it as:\n\n- predictable  \n- responsive  \n- expressive  \n- trustworthy in live performance  \n\n## Skills Demonstrated\n\n- DSP algorithm design  \n- Multi-method pitch estimation  \n- Confidence scoring & fusion  \n- vDSP FFT optimization  \n- Core Audio real-time pipelines  \n- Formant-preserving pitch shifting  \n- MIDI integration  \n- Low-latency engineering  \n- Performance optimization  \n\n## Narration / Reflection\n\nVIDI was a significant step in understanding **real-time DSP under real-world constraints**.  \nI learned how:\n\n- AMDF + autocorrelation + HPS complement one another  \n- confidence fusion stabilizes noisy estimates  \n- low-latency budgets drive architectural choices  \n- musicians value *feel* as much as technical accuracy  \n\nVIDI fused **DSP theory**, **musical sensitivity**, and **engineering practicality**, shaping how I approach\naudio systems, performance tuning, and perceptually meaningful DSP.\n\n---\n"
  },
  {
    "id": "skills/skills_master.md",
    "collection": "skills",
    "slug": "skills_master",
    "url": null,
    "word_count": 423,
    "data": {
      "visibility": "public",
      "use_for_ai": true
    },
    "content": "\n# Skills ‚Äì Wahaj Aslam\n\n## Core Programming & Engineering\n\n- **C (Primary)**  \n  - DSP modules, buffer flows, state machines, performance-sensitive logic  \n  - Used as main language at Fraunhofer (DSP / codec tooling) and u-blox (NAS state machines)\n\n- **Modern C++ (C++11/14/17)**  \n  - Media tools, Windows Media Foundation (MFT) integration, test harnesses  \n  - RAII, smart pointers, STL, modular structuring\n\n- **Python**  \n  - Evaluation frameworks, batch processing, plotting  \n  - Automation of codec tests, trace analysis, small research tools\n\n- **MATLAB**  \n  - DSP prototyping, spectral analysis, LPC, envelopes, filter design  \n  - Visualization GUIs (WARP multi-hop), thesis experiments\n\n- **Bash + GitLab CI**  \n  - Automation scripts, CI jobs, multi-step testing pipelines\n\n---\n\n## DSP & Audio Engineering\n\n- Spectral analysis (STFT, spectrograms)\n- LPC analysis, formant / envelope modeling\n- Filter design (FIR / IIR) for shaping and smoothing\n- Non-linear post-processing / excitation shaping\n- Speech bandwidth extension concepts (lowband ‚Üí wideband cues)\n- Experience with codec-oriented DSP workflows\n\n---\n\n## Critical Listening & Perceptual Evaluation\n\n- Hundreds of hours of internal listening tests at Fraunhofer\n- Trained to detect:\n  - pre-echo, transient smearing\n  - metallic ringing, ‚Äúsynthetic‚Äù timbre\n  - spectral holes, band mismatch\n  - stereo image instability\n  - roughness, noise, pumping artifacts\n- Comfortable correlating what I hear with:\n  - spectrograms (Audition, Python/MATLAB)\n  - waveform / difference signal analysis\n\n---\n\n## Streaming & Media Ecosystem\n\n- Understanding of:\n  - ABR ladders & multiple-bitrate configurations\n  - segment-based encoding behavior\n  - consistency across renditions / presets\n- Practical usage of:\n  - **FFmpeg** for pipelines and diagnostics\n  - **MediaInfo** for metadata checks\n  - MFT-based integration for Windows playback chains\n\n---\n\n## Tools\n\n- **Adobe Audition** ‚Äì detailed spectral + time-frequency inspection  \n- **FFmpeg** ‚Äì encoding/transcoding, ABR, test pipelines  \n- **MediaInfo** ‚Äì stream and codec metadata inspection  \n- Python + MATLAB plotting and analysis  \n- Git, GitLab CI, Bash automation\n\n---\n\n## Wireless & Academic Foundations\n\n- WARP SDR experiments (multi-hop, cooperative relays)\n- MATLAB visualization tools for wireless experiments\n- Academic seminar exposure to Massive MU-MIMO (linear precoding, CSI, beamforming ‚Äì not a\n  professional specialization)\n\n---\n\n## AI & Machine Learning ‚Äì Strategic Personal Expansion\n\n- Actively expanding into **AI-enhanced media and DSP workflows**:\n  - DSP‚ÄìAI hybrid thinking for audio enhancement and analysis\n  - Using small models and RAG concepts to structure engineering knowledge\n  - Treating AI as a layer on top of a strong DSP / media foundation\n- This is **personal innovation and learning**, not past employer work, and is focused on where  \n  media and audio technologies are heading rather than rebranding past roles."
  }
]